# 함수

## 함수란?

> 💡 프로그래밍 언어의 함수는 일련의 과정을 `문(statement)으로 구현`하고 코드 블록으로 감싸서 `하나의 실행단위로 정의`한 것

- `매개변수(parameter)` : 함수 내부로 입력을 전달받는 변수
- `인수(argument)` : 입력
- `반환값(return value)` : 출력
- `함수 정의(function definition)` : 함수 생성
- `함수 호출(function invoke)`: 인수를 매개변수를 통해 함수에 전달하면서 실행을 명시적으로 지시해야 함

<br />

## 함수를 사용하는 이유

> 💡 `동일한 작업을 반복적`으로 수행해야 한다면 같은 코드를 중복해서 여러 번 작성하는 것이 아니라 `미리 정의된 함수를 재사용하는 것이 효율적`

- 코드의 `재사용`
- 유지보수 `편의성`
- 코드의 `신뢰성`
- 코드의 `가독성`

<br />

## 함수 리터럴

> 💡 함수는 `객체 타입`으로 함수 리터럴은 `function 키워드`, `함수 이름`, `매개변수 목록`, `함수 몸체`로 구성

- 함수는 객체지만 일반 객체와 다르게 `호출`할 수 있으며 `함수 객체만의 고유한 프로퍼티`를 가짐
- `함수 이름`
  - 함수 이름은 `식별자`이므로 식별자 네이밍 규칙을 준수
  - 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자
  - 함수 이름은 생략 가능
    - 기명 함수 : 이름이 있는 함수
    - `익명 함수` : 이름이 없는 함수
- `매개변수 목록`
  - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분
  - 각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당, 매개변수 목록은 순서에 의미가 있음
  - 매개변수는 함수 몸체 내에서 변수와 동일하게 취급
- `함수 몸체`
  - 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록
  - 함수 몸체는 함수 호출에 의해 실행

<br />

## 함수 정의

> 💡 함수를 호출하기 이전에 `인수를 전달받을 매개변수와 실행할 문`들, 그리고 `반환할 값`을 지정

- 함수 선언문
  ```javascript
  function add(x, y) {
    return x + y;
  }
  ```
- 함수 표현식
  ```javascript
  var add = function(x, y) {
    return x + y;
  };
  ```
- 화살표 함수(ES6)
  ```javascript
  var add = (x, y) => x + y;
  ```
- Function 생성자 함수
  ```javascript
  var add = new FUnction('x', 'y', 'return x+y');
  ```

### 함수 선언문

> 💡 함수 선언문은 함수 리터럴과 형태가 동일

- 함수 선언문은 `표현식이 아닌 문`이므로 변수에 `할당 불가`
- 함수 `이름 생략 불가능`
- ⭐ 자바스크립트 엔진은 함수 선언문을 해석해 생성된 함수를 호출하기 위해 `함수 이름과 동일한 이름의 식별자를 암묵적으로 생성`해 `함수 객체 할당`
- 함수 이름으로 호출하는 것이 아닌 `함수 객체를 가리키는 식별자`로 호출

```javascript
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 의사 코드
//  식별자          함수 이름 
var add = function add(x, y) {
  return x + y;
};

// 함수 이름이 add가 아닌 식별자 add로 호출
console.log(add(2, 5));
```

### 함수 표현식

> 💡 함수는 일급 객체이므로 `함수 리터럴`로 생성한 `함수 객체를 변수에 할당`

- 함수 리터럴의 `함수 이름은 생략 가능`
  - 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적
- 함수 선언문이랑 유사하게 동작하는 것처럼 보이나 동일하게 동작하지 않음
  - `함수 표현식` : `표현식인 문`
  - 함수 선언문 : 표현식이 아닌 문

```javascript
var add = function(x, y) {
  return x + y;
};

console.log(add(2, 5));
```

### 함수 생성 시점과 함수 호이스팅

> 💡 함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시하므로 함수 선언문 대신 `함수 표현식 사용 권장`

- `함수 호이스팅` : 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유 특징
- ⭐ `함수 선언문`을 통해 암묵적으로 생성된 식별자는 `함수 객체`로 `초기화`
- `함수 표현식`으로 함수를 정의하면 `변수 호이스팅`이 발생
  - 변수 호이스팅은 `undefined`로 초기화
  - 변수 할당문의 값은 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 됨

```javascript
// 함수 참조
console.dir(add);           // f add(x, y)
console.dir(sub);           // undefined

// 함수 호출
// 함수 선언문으로 정의한 함수는 함수 선언문 전에 호출할 수 있음
console.log(add(2, 5));     // 7
// 함수 표현식으로 정의한 함수는 함수 선언문 전에 호출할 수 없음
console.log(sub(2, 5));     // TypeError: sub is not a function

// 함수 선언문
// 런타임 이전에 함수 객체가 먼저 생성
var add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```

### 화살표 함수

> 💡 ES6에서 도입, function 키워드 대신 `화살표 =>` 를 사용

- 화살표 함수는 항상 `익명 함수`로 정의
- 기존 함수와 `this 바인딩 방식이 다름`
- prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않음

```javascript
// 화살표 함수
const add = (x, y) => x + y;
```

### Function 생성자 함수

> 💡 자바스크립트가 기본 제공하는 빌트인 함수 `Function 생성자 함수` 사용

- 일반적이지 않으며 바람직하지 않음
- Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달
- new 연산자와 함께 호출하면 함수 객체 생성해 반환
- 클로저를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작

```javascript
// Function 생성자 함수
var add = new Function('x', 'y', 'return x + y');
```

<br />

## 함수 호출

> 💡 `식별자`와 `함수 호출 연산자()` 로 호출

- 함수 호출 연산자() 내에는 0개 이상의 인수를 쉼표로 구분해 나열
- 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮김

### 매개변수와 인수

> 💡 함수를 실행하기 위해 필요한 값을 `매개변수(parameter, 인자)`를 통해 `인수(argument)`를 전달

- `매개변수`
  - 함수를 `정의할 때 선언`
  - 함수 몸체 내부에서 변수와 동일하게 취급
  - 함수가 호출되면 암묵적으로 `매개변수가 생성`되고 일반 변수와 마찬가지로 `undefined로 초기화` 된 이후 `인수가 순서대로 할당`
  - 스코프(유효 범위)는 `함수 내부`
- `인수`
  - 값으로 평가될 수 있는 표현식
  - `함수를 호출할 때 지정`하며, `개수와 타입에 제한이 없음`
- 함수는 매개변수와 인수의 개수가 일치하는지 체크하지 않음
  - 인수가 할당되지 않은 매개변수의 값은 undefined
  - 초과된 인수는 무시되며 암묵적으로 arguments 객체의 프로퍼티로 보관

```javascript
function add(x, y) {
  return x + y;
}

console.log(add(2));          // NaN
console.log(add(2, 5, 10));   // 7
```

### 인수 확인

> 💡 자바스크립트 함수를 정의할 때 `적절한 인수가 전달`되었는지 `확인`할 필요가 있음

- 자바스크립트 함수는 매개변수와 인수의 개수가 일치는지 확인하지 않음
- 자바스크립트는 동적 타입 언어로 매개변수의 타입을 사전에 지정할 수 없음

### 매개변수의 최대 개수

> 💡 매개변수는 `순서에 의미`가 있으며 `적을수록 좋음`

- 매개변수의 개수가 많다는 것은 함수가 여러가지 일을 한다는 증거
- `이상적인 함수`는 `한 가지` 일만 해야 하며 `가급적 작게` 만들어야 함

### 반환문

> 💡 return 키워드와 표현식(반환값)으로 이뤄진 `반환문`을 사용해 실행 결과를 `함수 외부로 반환`

- `return 키워드` 사용해 자바스크립트에서 사용 가능한 모든 값을 `반환`할 수 있음
- `함수 몸체 내부`에서만 사용
- 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나감
- 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환
  - return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined 반환

```javascript
function multiply(x, y) {
  return x + y;
}

// 함수 호출은 반환값으로 평가
var result = multiply(3, 5);
console.log(result); //15
```

<br />

## 참조에 의한 전달과 외부 상태의 변경

> 💡 `참조에 의한 호출`은 `객체가 변경`될 수 있기 때문에 `상태 변화 추적이 어려움`

- `값에 의한 호출`
  - 원시 값은 변경 불가능한 값
  - 원시 타입의 argument는 `값 자체`가 복사되어 매개변수에 전달
  - 이 값을 변경(재할당)해도 원본은 훼손되지 않음
- `참조에 의한 호출`
  - 객체는 변경 가능한 값
  - 객체 argument는 `참조 값`이 복사되어 매개변수에 전달
  - 참조 값을 통해 전달한 객체를 변경할 경우 `원본 훼손`

```javascript
// 매개변수 primitive는 원시 값을 전달 받고, 매개변수 obj는 개체를 전달받음
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}

// 외부 상태
var num = 100;
var person = {name: 'Lee'};

console.log(num);     // 100
console.log(person);  // {name: "Lee"}

// 원시 값은 값 자체가 복사되어 전달되고 객체는 참조 값이 복사되어 전달
changeVal(num, person);

// 원시 값은 원본이 훼손되지 않음
console.log(num);     // 100

// 객체는 원본이 훼손
console.log(person);  // {name: "Kim"}
```

- 해결 방법
  - 객체를 `불변 객체(immutable object)`로 만들어 사용
    - 객체를 마치 원시 값처럼 변경 불가능한 값으로 동작하게 만들 수 있음
  - `깊은 복사(deep copy)`를 통해 새로운 객체를 생성하고 재할당 

<br />

## 다양한 함수의 형태

### 즉시 실행 함수

> 💡 `함수 정의`와 동시에 `즉시 호출`되는 함수

- `단 한번만 호출`되며 다시 호출할 수 없음
- `그룹 연산자(...)`로 감싸서 사용
- 익명 함수를 사용하는 것이 일반적

```javascript
(function foo() {
  var a = 3;
  var b = 5;
  return a * b;
}());

foo(); // ReferenceError: foo ist not defined
```

### 재귀 함수

> 💡 `재귀 호출`(자기 자신을 호출)을 수행하는 함수

- `반복되는 처리`를 위해 사용
- 함수 이름은 함수 몸체 내부에서만 유효하며, 함수 내부에서 `함수 이름`을 사용해 자기 자신을 호출
- 재귀 함수 내에는 호출을 멈출 수 있는 `탈출 조건`을 반드시 만들어야 함
  - 탈출 조건이 없으면 함수가 무한 호출되어 `스택 오버플로 에러` 발생

### 중첩 함수

> 💡 `함수 내부에 정의`된 함수로 외부 함수를 돕는 `헬퍼 함수`의 역할

- `중첩 함수` 또는 `내부 함수`라 함
- `외부 함수`는 중첩 함수를 포함하는 함수


### 콜백 함수

> 💡 함수의 매개변수를 통해 `다른 함수의 내부로 전달`되는 함수

- `콜백 함수`
  - 함수의 변하지 않는 공통 로직은 미리 정의해 두고, 경우에 따라 변경되는 로직은 추상화해 함수 외부에서 함수 내부로 전달
  - 고차 함수에 의해 호출
- `고차 함수`
  - `매개변수`를 통해 함수의 외부에서 `콜백 함수를 전달 받은 함수`
  - `콜백 함수`를 `자신의 일부분`으로 합성
  - 콜백 함수의 호출 시점을 결정해 호출
  - 고차 함수에 콜백 함수를 전달할 때 콜백 함수를 호출하지 않고 `함수 자체를 전달`해야 함

### 순수 함수와 비순수 함수

> 💡 `함수형 프로그래밍`은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 `최소화`해서 `불변성`을 지향하는 프로그래밍 패러다임

- `순수 함수`를 사용하는 것이 좋음
- `순수 함수`
  - 외부 상태에 의존하지도 않고 외부 상태를 변경하지도 않음(부수 효과가 있음)
  - 최소 하나 이상의 인수를 전달 받음
- `비순수 함수`
  - 외부 상태에 의존하거나 외부 상태를 변경(부수 효고가 없음)