# 객체 지향

## 01. 객체의 개념

> 💡 소프트웨어 객체는 현실 세계의 `객체`를 `필드(속성, 프로퍼티, 멤버변수)`와 `메서드`로 `모델링`한 것

- 소프트웨어 객체는 `상태`를 `필드`로 정의하고, `동작`을 `메서드`로 정의
- 필드는 객체 내부에 `선언된 변수`를 의미
- 메서드는 객체 내부에 정의된 `동작`

### 객체와 클래스

> 💡 클래스는 `필드(상태)`와 `메서드(동작)`로 구성

- `클래스` : 동일한 객체를 만드는 설계도
- `객체` : 클래스로 만든 객체가 해당 `클래스의 인스턴스`

<br />

## 02. 객체 지향 프로그래밍 특징

### 캡슐화

> 💡 관련된 필드와 메서드를 하나의 캡슐처럼 포장해 세부 내용을 `외부에서 알 수 없도록 감추는 것`(정보은닉)

### 상속

> 💡 상위 객체를 상속받은 `하위 객체`가 `상위 객체의 메서드와 필드`를 사용

- 개발된 객체를 `재사용`하는 방법 중 하나
- `상위` 객체 클래스 = `부모` 클래스 = `슈퍼` 클래스 = `기본` 클래스
- `하위` 객체 클래스 = `자식` 클래스 = `서브` 클래스 = `파생` 클래스 = `확장` 클래스

### 다형성

> 💡 대입되는 객체에 따라서 `메서드를 다르게 동작`하도록 구현

<br />

## 03. 클래스의 선언과 객체 생성

### 클래스의 선언

- `객체를 추상화`할 때 `상태를 필드`로, `동작을 메서드`로 정의해서 `클래스로 선언`
  - `추상화` : 현실 세계의 객체에서 불필요한 속성을 제거하고 중요한 정보만 클래스로 표현하는 모델링 기법
- 하나의 클래스가 둘 이상 있다면 `하나만 public`으로 선언할 수 있음

```java
// 접근권한 클래스키워드 클래스이름
public class Ball{
  double radius = 2.0 // 필드
  double getVolumn() { // 메서드
    return 4 / 3 * 3.14 * radius * radius * radius 
  }
}
class Cylinder {}
```

### 객체 생성과 참조 변수

> 💡 클래스이름 변수 = new 클래스이름();

- `new 연산자` : 객체를 생성할 때 사용하며 `생성한 객체의 주소` 반환

```java
// 기초 타입 => 실제 데이터 10 저장
int ten = 10; 
// 참조 타입 => Ball 객체를 가리키는 주소 저장
Ball myBall = new Ball(); 
```

<br />

## 04. 클래스의 구성 요소와 멤버 접근

> 💡 `클래스`는 `필드`와 `메서드`로 구성되며 이 둘을 합쳐 클래스의 `멤버`라고 함

- `필드` : 객체의 속성이나 상태
- `메서드` : 해당 객체에서 수행할 동작 
- `생성자` : new 연산자로 호출하는 특수한 메서드

### 필드와 지역 변수

- `필드` : 메서드 내부를 제외한 `클래스 내부`의 어디에서든 위치
  - 선언할 때 명시적으로 초기화할 수 있으며 기본값이 있어 초기화하지 않고도 사용가능
  - 클래스 전체에서 사용 가능
  - 모든 접근 지정자뿐만 아니라 static, final로 지정 가능
- `지역 변수` : `매개변수나 메서드 내부`에서 선언된 변수
  - 다른 블록에 선언된 지역 변수의 이름이 같지 않아야 함
  - 초기화하지 않은 채 사용하면 오류 발생
  - 선언된 블록 내부에서만 사용 가능
  - final로만 지정 가능

### 필드와 메서드 접근

> 💡 객체참조변수.멤버

- 메서드나 필드는 객체에 소속된 멤버이므로 `해당 클래스의 객체를 생성해 접근`
- 클래스 내부에서 자신의 멤버에 접근하려면 `this`를 사용하거나 `필드 이름`이나 `메서드 이름` 그대로 사용

<br />

## 05. 접근자와 설정자

> 💡 클래스 내부에 은닉한 필드를 외부에서 사용할 수 있도록 `접근자`와 `설정자`를 제공해야 함

- 일반적으로 `접근자`는 `get`, `설정자`는 `set`으로 시작하는 이름 사용
  - 클래스 멤버를 `외부에서 조작할 수 없도록` 멤버 앞에 `private` 지정
  - 클래스의 모든 멤버를 private로 지정하면 외부 클래스에서 해당 클래스를 사용할 수 없음

<br />

## 06. 생성자

> 💡 `객체를 생성하는 시점`부터 필드를 다양하게 `초기화`할 수 있도록 생성자 제공

### 생성자의 개념과 선언

- 생성자 이름은 클래스 이름과 같음
- 생정자의 반환 타입은 없음
- 생성자도 new 연산자와 함께 사용하며, 객체를 생성할 때 호출
- 생성자도 오버로딩 할 수 있음

```java
// 생성자 : 클래스이름(...)
클래스 이름 변수 = new 클래스이름(...);
```

### 디폴트 생성자와 생성자 오버로딩

> 💡 생성자를 선언하지 않으면 컴파일러가 자동으로 `디폴트 생성자` 추가

- `디폴트 생성자` : 매개변수도 없고 본체에서 실행할 내용도 없는 생성자
  - `모든 클래스`는 `생성자를 하나 이상` 꼭 가짐
  - 클래스에 다른 생성자가 하나라도 있으면 디폴트 생성자를 자동으로 추가하지 않음
- 생성자도 `오버로딩`할 수 있음

### this와 this()

> 💡 변수 이름이 같아도 멤버 필드와 매개변수를 구별할 수 있음

- `this`는 생성자에 의해 생성된 `객체 자신`
- `this()`를 사용할 때는 반드시 `생성자의 첫 행`에 위치

### 연속 호출

> 💡 여러 메서드를 하나의 실행문에서 연속해 호출하는 기법

```java
// Person person = new Person();
// person = person.setName("가희");
// person = person.setAge(21);
// person.sayHello();

Person person = new Person();
person.setName("가희").setAge(21).sayHello();
```

<br />

## 07. 정적 멤버

### 인스턴스 멤버와 정적 멤버

> 💡 `static` 키워드로 클래스의 필드를 공유

- `정적 변수(클래스 변수)` 또는 `정적 메서드`
  - 모든 인스턴스가 필드 공유
  - 객체를 `여러 개 생성`해도 정적 변수는 `하나뿐`이며, `모든 객체가 공유`
  - 클래스 로더가 클래스를 메서드 영역에 적재할 때 생성하므로 `객체 생성 전`에도 `접근 가능`
- `인스턴스 변수` 또는 `인스턴스 메서드`
  - static 키워드로 지정되지 않은 필드는 공유되지 않고 인스턴스마다 자신의 필드 생성
  - 객체별로 관리
  - `객체를 생성한 후`에 `접근`할 수 있으며, 객체가 소멸될 때 자동 소멸
- `정적 멤버` 유의사항
  - 객체와 관련된 인스턴스 변수를 사용할 수 없음
  - 객체와 관련된 인스턴스 메서드를 호출할 수 없음
  - 객체 자신을 가리키는 this 키워드를 사용할 수 없음

### 정적 멤버의 활용

- 정적 변수의 대표적인 예 : 상수
- 정적 메서드의 대표적인 예 : main()
- 일반적으로 객체 이름 대신에 `클래스 이름`과 연결해서 사용
  - 클래스이름.정적변수이름
  - 클래스이름.정적메서드이름()

### 정적 블록

- 정적 변수도 인스턴스 변수처럼 선언과 동시에 초기화할 수 있음
- 정적 변수의 `초기화가 복잡`할 때 `정적 블록을 사용`할 수 있음
  - 정적 블록도 클래스 로더가 클래스를 메서드 영역에 적재할 때 실행

```java
public class OneToTenDemo{
  static int sumOneToTen;

  // 정적 블록으로 정적 변수 초기화
  static{
    ins um = 0;
    for(int i = 1; i <= 10; i++) {
      sum += i;
    }
    sumOnToTem = sum;
  } 
}

public static void main(String[] args) {
  System.out.println(sumOneToTen);}
```