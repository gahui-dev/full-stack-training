## 자바 프로그램 구조와 기초 문법

### 01. 자바 프로그램 기본 구조

- 소스 파일 = 클래스 > 메서드 > 실행문
- `클래스(class)`
    - 객체 지향 언어에서 클래스는 프로그램을 개발하는 단위
    - 클래스 내부에는 여러 개의 메서드가 포함될 수 있음
- `메서드(method)`
    - 수행할 작업을 나열한 코드의 모임
    - 자바 애플리케이션은 main() 메서드부터 실행을 시작
- `실행문(statement)`
    - 작업을 지시하는 변수 선언, 값 저장, 메서드 호출 등의 코드를 의미
- `주석문`
    - 프로그램에 덧붙이는 설명문으로 컴파일러가 무시하는 문장
    - `행` 주석 ⇒ `//` 부터 행 끝까지를 주석으로 처리
    - `범위` 주석 ⇒  `/* 와 */` 사이를 주석으로 처리
    - `문서` 주석 ⇒ `/** 와 */` 사이를 주석으로 처리하되 javadoc.exe 명령어로 `API 문서`를 생성하는데 사용

## 2. 식별자

> 💡 프로그램에서 사용하는 변수, 메서드, 클래스, 상수 등을 `이름`으로 구별하는데, 이것을 `식별자`라 함

### 01. 식별자

- 문자, 언더바(_), $로 시작해야 함
- 한글도 가능하며, 영문자는 대소문자를 구분
- +, - 등 연산자를 포함하면 안됨
- 자바 키워드를 사용하면 안됨

```java
// 변수와 메서드는 모두 소문자로 표기
// 복합 단어일 때 두 번째 단어부터 단어의 첫 자만 대문자로 표기
int thisYear;
String currentPosition;
boolean isEmpty;
public int getYear() {}

// 클래스와 인터페이스는 첫 자만 대문자로 표기
// 복합 단어일 때 각 단어의 첫 자만 대문자로 표기
public class HelloDemo {}
public interface MyRunnable {}

// 상수는 전체 대문자 표기
// 복합 단어일 때 언더바(_)로 연결
final int NUBMER_ONE = 1;
final double PI = 3.141592;
```

### 02. 자바 키워드

| 분류 | 키워드 |
| -------- | --- |
| 데이터 타입 | byte, char, short, int, long, float, double, boolean |
| 접근 지정자 | private, protected, public |
| 제어문 | if, else, for, while, do, break, continue, switch, case |
| 클래스와 객체 | class, interface, enum, extends, implements, new, this, super, instanceof, null |
| 예외 처리 | try, catch, finally, throw, throws |
| 기타 | abstract, assert, const, default, false, final, import, native, package, return, static, strictfp, synchronized, transient, true, void, volatile |

## 3. 변수

### 01. 변수의 개념

- 프로그램은 `메모리 공간`에 데이터를 보관
- 여러 메모리 공간을 `변수`로 구분
- 이를 구분하기 위해 `데이터 타입`을 사용

### 02. 데이터 타입과 리터럴

- 데이터 타입은 값과 값을 다룰 수 있는 연산의 집합
- 기초 타입 ⇒ 정수, 문자, 실수, 논리

| 분류 | 기초 타입 | 기억 공간 크기 | 기본값 | 값의 범위 |
| --- | --- | --- | --- | --- |
| 정수 | byte | 8비트 | 0 | -128~127 |
| 정수 | short | 16비트 | 0 | -32,768~32,767 |
| 정수 | int | 32비트 | 0 | -2,147,483,648~2,147,483,647 |
| 정수 | long | 64비트 | 0L | -9,223,372,036,854,775,808 ~ -9,223,372,036,854,775,807 |
| 문자 | char | 16비트 | \0000 | 0(’\u0000’)~65,535(’\uFFFF’) |
| 실수 | float | 32비트 | 0.0f | 약 ±3.4*10^-38 ~ ±3.4*10^38 |
| 실수 | double | 64비트 | 0.0d | 약 ±1.7*10^-308~±1.7*10^308 |
| 논리 | boolean | 8비트 | false | true와 false |
- 참조 타입 ⇒ 배열, 열거, 클래스, 인터페이스

### 정수

> 💡 기본적으로 `int` 타입이고 값의 범위에 따라 `byte, short, long` 사용

- 2진수: `0b`
- 8진수: `0`
- 16진수: `0x`

```java
int fifteen = 15;      // 10진수 
byte fifteen = 0b1111; // 2진수 15
short fiftenen = 017;  // 8진수 15
int fifteen = 0xF;     // 16진수 15
long lightSpeed = 300000L // L은 long타입임을 명시
```

### 실수

> 💡 기본적으로 `double` 타입이고 값의 범위에 따라 `float` 사용

- 일반 표기법, 지수 표기법
- `float` 타입 : F, f

```java
double half = 0.5;  // 일반 표기법
double half = 5E-1; // 지수 표기법, 5x10^(-1) 의미
float pi = 3.14159; // 오류
float pi = 3.14159F;  // F는 float 타입임을 명시
double pi = 3.14159;
```

###문자

> 💡 `char` 타입을 사용, 비영어권 언어까지 최대 `6만 5천개` 문자를 처리할 수 있도록 내부적으로 `유니코드`(2바이트 문자 처리 방식) 사용

### 논리

> 💡 `boolean` 타입 사용. 논리 리터럴은 `true`와 `false`로 표현

<br />

## 03. 변수 사용

> 💡 변수에 저장할 `데이터 타입을 지정`하고 `이름`을 붙이는 것

```java
int weight;     // 정수 타입의 weight 변수 선언
double x, y, z; // 3개의 변수를 , 로 연결해 선언

```

## 04. 상수

> 💡 프로그램 실행 도중 `변경할 수 없는 데이터`를 담는 변수

- `final` 키워드로 반드시 지정
- 상수 이름을 모두 `대문자`로 표기

## 05. 타입 변환

> 💡 데이터 타입을 바꾸는 연산

### 자동 타입 변환

- 프로그램 실행 중 자동으로 타입이 변환
- 가장 큰 데이터 타입으로 모든 데이터 타입 통합

```java
// 정수 5를 실수 5.0으로 자동 타입 변환
double d1 = 5 * 3.14; 
// 정수 1을 실수 1.0으로 자동 타입 변환
double d2 = 1;
```

### 강제 타입 변환

- `타입 변환 연산자`를 사용해 강제로 변환하는 연산

```java
// double의 3.14를 float로 형 변환해 f에 3.14F 저장
float f = (float)3.14;

// int의 300을 byte로 형 변환하면 데이터 손실 발생
byte b = (byte)300;

// double의 3.14를 byte로 형 변환하면 데이터가 손실되고 3만 저장
byte x = (byte)3.14;

// float의 3.14를 double로 형 변환하면 데이터 손실 없이 저장
double d = (double)3.14;

```

## 06. 자바 기본 입출력

### 데이터 출력

- `println()` : 내용 출력 후 `행 바꿈`
- `print()` : 내용 출력후 `행 바꾸지 않음`
- `printf()` : 지정된 `포맷`을 사용해 출력

### 데이터 입력

1. 프로그램의 첫 행에 다음을 추가해 `Scanner` 클래스의 경로 이름을 알림
	```java
	import java.util.Scanner;
	```

2. 키보드로 데이터를 입력받으려고 System.in 객체와 연결된 Scanner 객체 생성

	```java
	Scanner in = new Scanner(System.in);
	```

3. Scanner 클래스가 제공하는 다양한 메서드를 이용해 `키보드로 데이터를 입력 받음`

	```java
	int x = in.nextInt();  // 정수를 읽어 x 변수에 대입
	```

## 07. 연산자

### 연산자 종류

| 종류 | 연산자 | 설명 | 비고 |
| --- | ----- | ----| --- |
| 증감 | ++, -- | 1만큼 증가 또는 감소 | 단항 |
| 산술 | +, -, *, /, % | 사칙연산과 모듈로 연산 | 이항 |
| 시프트 | >>, <<, >>> | 비트를 좌우로 이동 | 이항 |
| 부호 | +, - | 부호 변환 | 단항 |
| 비교 | >, <, >=, <=, ==, !=, instanceof | 데이터 값을 비교하거나 데이터 타입을 비교 | 이항 |
| 비트 | &, \|, ~, ^ | 비트 단위의 AND, OR, NOT, XOR | 단항, 이항 |
| 논리 | &&, \|\|, !, ^ | 논리적 AND, OR, NOT, XOR | 단항, 이항 |
| 조건 | (expr) ? x : y | expr에 따라 참이면 x, 거짓이면 y | 삼항 | 
| 대입 | =, +=, -=, *=, /=, &=, \|=, ^=, >>=, <<=, >>>= | 오른쪽 값을 연산해 왼쪽에 대입 | 이항 |

### 산술 연산자

> 💡 +, -, *, /, %

- 두 피연산자의 데이터 타입이 다르면 `큰 범위의 타입`으로 `일치`시킨 후 연산 수행
- 논리 타입을 제외한 기초 타입을 피연산자로 사용할 수 있음(단, % 연산자는 정수 타입에서만 사용)
- 덧셈 연산자는 `문자열`을 연결하는데도 사용
  - 문자열과 덧셈을 하는 데이터는 먼저 문자열로 변환 후 서로 연결

### 비교 연산자

> 💡 2개의 피연산자를 비교해 결괏값으로 논릿값인 true나 false를 돌려줌

- ==와 !=는 모든 타입에 사용할 수 있지만, 그 외 비교 연산자는 논리 타입을 제외한 기초 타입에만 사용

| 연산자 | 사용 예 | 설명
| ----- | ----| --- |
| == | x == y | x와 y는 같은가? |
| != | x != y| x와 y는 다른가? |
| > | x > y| x는 y보다 큰가?|
| >= | x >= y| x는 y보다 크거나 같은가? |
| < | x < y | x는 y보다 작은가? |
| <= | x <= y| x는 y보다 작거나 같은가 ? |

### 논리 연산자 

> 💡 피연산자의 조건을 결합해서 `true`와 `false`를 조사하며, `논리 타입`에만 사용

| a | b | !a | a&&b | a\|\|b | a^b |
| - | - | -- | --- | --- | --- |
| false | false | true | false | false | false
| false | true | true | true | true | true
| true | false | false | true | true | true
| true | true | false | true | true | false | 

- &&와 || 연산자 대신에 &와 |를 사용할 수 있지만 &와 |는 `쇼트서킷(short circuit)`을 `사용하지 않음`

```java
// 조건식 1이 false이면 조건식 2의 진룃값과 상관없이 결과가 무조건 false
// 따라서 조건식 2의 진룃값을 조사할 필요 없음
조건식1 && 조건식2
// 조건식 1이 true이면 조건식 2의 진룃값과 상관없이 결과가 무조건 true
// 따라서 조건식 2의 진룃값을 조사할 필요 없음
조건식1 || 조건식2
```

### 비트 연산자

> 💡 정수 타입에만 사용하며, `비트 단위`로 연산 수행

| 연산자 | 설명 |
| ---- | ---- |
| & | 두 비트가 모두 1일 때만 1이며, 나머지는 모두 0 |
| \| | 두 비트가 모두 0일 때만 0이며, 나머지는 모두 1 |
| ^ | 두 비트가 서로 다를 때는 1, 동일할 때는 0 |
| ~ | 1을 0으로, 0을 1로 바꿈 |

### 시프트 연산자

| 연산자 | 피연산자 a와 b로 연산할 경우 |
| ---- | ---- |
| << | a의 모든 비트를 `왼쪽`으로 b비트 만큼 이동하며, 이동할 때마다 `최하위 비트를 0`으로 채움, `곱셈` 효과, `산술적 왼쪽 시프트`|
| >> | a의 모든 비트를 `오른쪽`으로 b비트만큼 이동하며, 이동할 때마다 `최상위 비트와 동일한 비트`로 채움, `나눗셈` 효과, `산술적 오른쪽 시프트` |
| >>> | a의 모든 비트를 `오른쪽`으로 b비트만큼 이동하며, 이동할 때마다 `최상위 비트를 0`으로 채움, `논리적 오른쪽 시프트` |

### 대입 연산자

> 💡 오른쪽에 있는 `연산식의 결괏값`을 왼쪽에 있는 `변수에 저장`

### 부호 연산자

> 💡 숫자를 나타내는 `기초 타입`에 사용하며 피연산자의 부호를 `그대로 유지`하거나 `반전`

| 연산자 | 설명 |
| ---- | ---- |
| + | 부호 유지 |
| - | 부호 반전 |

### 증감 연산자

> 💡 변숫값을 `1 증가`하거나 `감소`하는 연산자로 논리 타입을 제외한 `기초 타입`에 사용

| 연산자 | 설명 |
| ---- | ---- |
| ++x | 연산 전 x값 증가(전위 증가) |
| x++ | 연산 후 x값 증가(후위 증가) |
| --x | 연산 전 x값 감소(전위 감소) |
| x-- | 연산 후 x값 증가(후위 감소) |

### 조건 연산자

> 💡 조건식이 `true`이면 결괏값은 `연산식 1`의 값이 되고, `false` 이면 결괏값은 `연산식 2`의 값이 됨

```java
조건식 ? 연산식 1 : 연산식2
```